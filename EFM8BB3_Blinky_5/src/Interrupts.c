//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

         
// USER INCLUDES			
/*
#include <SI_EFM8BB3_Register_Enums.h>

//-----------------------------------------------------------------------------
// Global VARIABLES
//-----------------------------------------------------------------------------
int CLKCOUNT = 0;
//-----------------------------------------------------------------------------
// Global CONSTANTS
//-----------------------------------------------------------------------------
SI_SBIT(CLK, SFR_P1, 1);
SI_SBIT(BIT0, SFR_P1, 2);                  // P1.4 LED0
SI_SBIT(BIT1, SFR_P1, 3);
SI_SBIT(BIT2, SFR_P1, 4);                  // P1.4 LED0
SI_SBIT(BIT3, SFR_P1, 5);                  // P1.5 LED1
SI_SBIT(BIT4, SFR_P1, 6);					// P1.6 LED2
SI_SBIT(BIT5, SFR_P1, 7);

//-----------------------------------------------------------------------------
// TIMER2_ISR
//-----------------------------------------------------------------------------
//
// TIMER2 ISR Content goes here. Remember to clear flag bits:
// TMR2CN::TF2H (Timer # High Byte Overflow Flag)
// TMR2CN::TF2L (Timer # Low Byte Overflow Flag)
//
// This routine changes the state of the LED whenever Timer2 overflows.
//
//-----------------------------------------------------------------------------
SI_INTERRUPT (TIMER2_ISR, TIMER2_IRQn)
{
	TMR2CN0_TF2H = 0;    // Clear Timer2 interrupt flag
	uint8_t n=0;

	switch (CLKCOUNT)
	{
		case 0:

			BIT0=outb[0];
			BIT1=outb[1];
			BIT2=outb[2];
			BIT3=outb[3];
			BIT4=outb[4];
			BIT5=outb[5];
			/*for(n=0; n<=1000; n++){
				Nop();
			}
			CLK=1;
		   break;
		case 1:
		   CLK=1;
		   break;
		case 2:
		   CLK=0;
		   IE_EA=0;
		   break;

	}
	if (CLKCOUNT <= 1) CLKCOUNT++;
	else CLKCOUNT = 0;
}

*/

